<!DOCTYPE html>
<html lang="en">
<head><script src="wrapWebGL25.js"></script>
    <meta charset="utf-8">
    <title>Custom Rubik's</title>
    <link rel="icon" href="/rubixcube.png">
    <script src="math20.js"></script>

    <!-- TO DO: fix normal colors of borders, fix centroid bug, fix teapot filetype handling -->

<!-- The source code of a vertex shader directly in the HTML. The 'type=' command can have any value except "javascript" and just tells the browser not to try to run the code as javascript. -->
<script id="vert" type="glsl">
#version 300 es
layout(location=0) in vec4 position;
layout(location=1) in vec4 color;
layout(location=2) in vec3 normal;
layout(location=3) in vec2 texCoord;
out vec4 color2;
out vec3 vnormal;
out vec2 vTexCoord;
out float xval;
out float yval;
out float zval;
uniform mat4 mv;
uniform mat4 p;
void main() {
    gl_Position = p * mv * position;
    vnormal = mat3(mv) * normal;
    xval = position.x;
    yval = position.y;
    zval = position.z;
    color2 = color;
    vTexCoord = texCoord;
}
</script>


<!-- The source code of a fragment shader. -->
<script id="frag" type="glsl">
#version 300 es
precision highp float;
uniform vec4 color;
uniform vec3 lightdir;
uniform vec3 halfway;
uniform vec3 lightcolor;
uniform sampler2D img_texture;
out vec4 fragColor;
in vec3 vnormal;
in vec4 color2;
in vec2 vTexCoord;
void main() {
    // fragColor = color2;
    vec4 texColor = texture(img_texture, vTexCoord);
    vec3 N = normalize(vnormal);
    vec3 L = normalize(lightdir);
    float lambert = max(dot(N, L), 0.0);
    vec3 diffuse = lightcolor * lambert;
    float blinn = pow(max(dot(N, halfway), 0.0), 64.0) * (3.0 * color2.a); // alpha used to multiply spec light
    vec3 specular = lightcolor * blinn;
    vec3 epic = vec3(1.0,0.0,1.0);
    // fragColor = texColor * vec4(epic.rgb * (diffuse) + specular, 1.0);
    fragColor = vec4(epic.rgb * (diffuse), 0.05);
}
</script>

<!-- The source code of a fragment shader. -->
<script id="fragDef2" type="glsl">
    #version 300 es
    precision highp float;
    uniform vec4 color;
    uniform vec3 lightdir;
    uniform vec3 halfway;
    uniform vec3 lightcolor;
    uniform sampler2D img_texture;
    out vec4 fragColor;
    in vec3 vnormal;
    in vec4 color2;
    in vec2 vTexCoord;
    in float xval;
    in float yval;
    in float zval;
    void main() {
        // fragColor = color2;
        vec4 texColor = texture(img_texture, vTexCoord);
        vec3 N = normalize(vnormal);
        vec3 L = normalize(lightdir);
        float lambert = max(dot(N, L), 0.0);
        vec3 diffuse = lightcolor * lambert;
        float blinn = pow(max(dot(N, halfway), 0.0), 16.0); // alpha used to multiply spec light
        vec3 specular = lightcolor * blinn;
        // cube blue
        //if  (color2.b == 1.0 && color2.g == 0.0) {
        //    fragColor = vec4(color2.rgb * (diffuse) + specular, 0.8);
        //}
        // object blue
        // xval < 0.5 && xval > -0.5 && zval < 0.5 && zval > -0.5 && (yval > -1.0 || yval == -1.0) && yval < -0.5
        //if (zval < 0.5 && xval < 0.5 && xval > -0.5 && yval < 0.5 && yval > -0.5) { // 
        //    fragColor = vec4(0.0, 0.0, (color2.rgb * (diffuse) + specular + 0.25).b, 1.0);
        //} else {
            // fragColor = vec4(0.0, 0.0, 1.0, 1.0);
            fragColor = vec4(color2.rgb * (diffuse) + specular, 1.0);
        //}
    }
    </script>

    <script id="fragDef" type="glsl">
        #version 300 es
        precision highp float;
        uniform vec4 color;
        uniform vec3 lightdir;
        uniform vec3 halfway;
        uniform vec3 lightcolor;
        uniform sampler2D img_texture;
        out vec4 fragColor;
        in vec3 vnormal;
        in vec4 color2;
        in vec2 vTexCoord;
        in float xval;
        in float yval;
        in float zval;
        void main() {
            // fragColor = color2;
            vec4 texColor = texture(img_texture, vTexCoord);
            vec3 N = normalize(vnormal);
            vec3 L = normalize(lightdir);
            float lambert = max(dot(N, L), 0.25);
            vec3 diffuse = lightcolor * lambert;
            float blinn = pow(max(dot(N, halfway), 0.0), 16.0); // alpha used to multiply spec light
            vec3 specular = lightcolor * blinn;
            
            // Define target colors for each side:
            vec3 frontColor  = vec3(0.65, 0.0, 0.75);   // purple
            vec3 rightColor  = vec3(0.0, 1.0, 1.0);   // cyan
            vec3 leftColor   = vec3(0.0, 0.0, 1.0);   // blue
            vec3 topColor    = vec3(1.0, 1.0, 0.0);   // yellow
            vec3 bottomColor = vec3(1.0, 0.0, 1.0);   // magenta
            
            // Compute weights for each side using dot products.
            // Note: adjust the direction vectors as needed for your model.
            float wFront  = max(dot(N, vec3(0.0, 0.0, 1.0)), 0.0);
            float wRight  = max(dot(N, vec3(1.0, 0.0, 0.0)), 0.0);
            float wLeft   = max(dot(N, vec3(-1.0, 0.0, 0.0)), 0.0);
            float wTop    = max(dot(N, vec3(0.0, 1.0, 0.0)), 0.0);
            float wBottom = max(dot(N, vec3(0.0, -1.0, 0.0)), 0.0);
            
            float total = wFront + wRight + wLeft + wTop + wBottom;
            // To avoid division by zero, if total is 0, default to white.
            vec3 sideColor = (total > 0.0)
                ? (wFront*frontColor + wRight*rightColor + wLeft*leftColor + wTop*topColor + wBottom*bottomColor) / total
                : vec3(1.0);
            
            
            fragColor = vec4(sideColor * diffuse + specular, 1.0);

            if  (color2.b == 1.0) {
                fragColor = vec4(0.75, 0.75, 0.75, 1.0);
                // fragColor = vec4(sideColor * diffuse + specular, 1.0);
            }
        }
    </script>
    

<!-- Code I don't expect to change. -->
<script>
const IlliniWhite = new Float32Array([1, 1, 1, 1])
const IdentityMatrix = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1])

/**
 * Given the source code of a vertex and fragment shader, compiles them,
 * and returns the linked program.
 */
function compileShader(vs_source, fs_source) {
    // Create and compile the vertex shader
    const vs = gl.createShader(gl.VERTEX_SHADER)
    gl.shaderSource(vs, vs_source)
    gl.compileShader(vs)
    // Checks if vertex shader compiled successfully -> if not, log the error
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(vs))
        throw Error("Vertex shader compilation failed")
    }
    // Create and compile the fragment shader
    const fs = gl.createShader(gl.FRAGMENT_SHADER)
    gl.shaderSource(fs, fs_source)
    gl.compileShader(fs)
    // Checks if fragment shader compiled successfully -> if not, log the error
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(fs))
        throw Error("Fragment shader compilation failed")
    }
    // Create the shader program, attaches both vertex and fragment shaders
    const program = gl.createProgram()
    gl.attachShader(program, vs)
    gl.attachShader(program, fs)
    gl.linkProgram(program) // <-- Link the shaders into the program
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program))
        throw Error("Linking failed")
    }
    // Store uniform locations here
    const uniforms = {}
    for(let i=0; i<gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i+=1) {
        let info = gl.getActiveUniform(program, i)
        uniforms[info.name] = gl.getUniformLocation(program, info.name)
    }
    program.uniforms = uniforms

    return program
}

/**
 * Sends per-vertex data to the GPU and connects it to a VS input
 * 
 * @param data    a 2D array of per-vertex data (e.g. [[x,y,z,w],[x,y,z,w],...])
 * @param loc     the layout location of the vertex shader's `in` attribute
 * @param mode    (optional) gl.STATIC_DRAW, gl.DYNAMIC_DRAW, etc
 * 
 * @returns the ID of the buffer in GPU memory; useful for changing data later
 */
function supplyDataBuffer(data, loc, mode) {
    if (mode === undefined) mode = gl.STATIC_DRAW
    
    const buf = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buf)
    const f32 = new Float32Array(data.flat())
    gl.bufferData(gl.ARRAY_BUFFER, f32, mode)
    
    gl.vertexAttribPointer(loc, data[0].length, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(loc)
    
    return buf;
}

/**
 * Creates a Vertex Array Object and puts into it all of the data in the given
 * JSON structure, which should have the following form:
 * 
 * ````
 * {"triangles": a list of of indices of vertices
 * ,"attributes":
 *  [ a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 0
 *  , a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 1
 *  , ...
 *  ]
 * }
 * ````
 * 
 * @returns an object with four keys:
 *  - mode = the 1st argument for gl.drawElements
 *  - count = the 2nd argument for gl.drawElements
 *  - type = the 3rd argument for gl.drawElements
 *  - vao = the vertex array object for use with gl.bindVertexArray
 */
function setupGeomery(geomA) { // changed param name during faulty intial implementation of rendering multiple shapes
    var triangleArray = gl.createVertexArray()
    // console.log("setGeomery() called")
    gl.bindVertexArray(triangleArray)
    // console.log("attributes")
    // console.log(geomA)
    for(let i=0; i<geomA.attributes.length; i+=1) {
        let data = geomA.attributes[i]
        supplyDataBuffer(data, i)
    }

    var indices = new Uint16Array(geomA.triangles.flat())
    var indexBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)
    // console.log("setup geom:")
    // console.log(geomA)
    return {
        mode: gl.TRIANGLES,
        count: indices.length, //+ indices2.length,
        faceCount: geomA.triangles.length,
        type: gl.UNSIGNED_SHORT,
        vao: triangleArray
        // vao: tetrahedronArray
    }
}

var maxVert = 0;
var normOk = 0;

function addNormals(geom) {
    // add norm only once after load
    maxVert = 0;
    if (normOk === 1) {
        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            for (let j = 0; j < 3; j += 1) {
                if (Math.abs(geom.attributes[0][i][j]) > Math.abs(maxVert) && geom.attributes[0][i][j] !== 0.0) {
                    maxVert = geom.attributes[0][i][j];
                }
                if (geom.attributes[0][i][j] === -1.0 * maxVert && maxVert < 0.0) {
                    maxVert = geom.attributes[0][i][j];
                }
            }
            
        }
        let mult = 1.0 / maxVert
    
        // console.log("Max vert = ", maxVert)
        if (maxVert !== 0) {
            for (let i = 0; i < geom.attributes[0].length; i += 1) {
                for (let j = 0; j < 3; j += 1) {
                    geom.attributes[0][i][j] /= maxVert;
                    if (maxVert - 1.0 >= 0.01) {
                        geom.attributes[0][i][j] *= 1.5; 
                    }
                }
            }
        }
        normOk = 0;
    }
    
    let minX = geom.attributes[0][0][0];
    let maxX = geom.attributes[0][0][0];
    let minY = geom.attributes[0][0][1];
    let maxY = geom.attributes[0][0][1];
    let minZ = geom.attributes[0][0][2];
    let maxZ = geom.attributes[0][0][2];
    if (floorOrCube == 0) {
        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            if (geom.attributes[0][i][0] < minX) {
                minX = geom.attributes[0][i][0];
            } if (geom.attributes[0][i][0] > maxX) {
                maxX = geom.attributes[0][i][0];
            } if (geom.attributes[0][i][1] < minY) {
                minY = geom.attributes[0][i][1];
            } if (geom.attributes[0][i][1] > maxY) {
                maxY = geom.attributes[0][i][1];
            } if (geom.attributes[0][i][2] < minZ) {
                minZ = geom.attributes[0][i][2];
            } if (geom.attributes[0][i][2] > maxZ) {
                maxZ = geom.attributes[0][i][2];
            }
        }
        let extremeVals = [maxX - minX, maxY - minY, maxZ - minZ];
        let maxVal = 0;
        for (let i = 0; i < extremeVals.length; i += 1) {
            let curr = extremeVals[i];
            if (Math.abs(curr) > Math.abs(maxVal)) {
                maxVal = curr;
            }
        }
        // console.log("MaxVAL = ", maxVal)
        let scalar = 1.0 / maxVal;
        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            geom.attributes[0][i][0] *= scalar;
            geom.attributes[0][i][1] *= scalar;
            geom.attributes[0][i][2] *= scalar;
        }
    }
    if (firstTime == 1) {
        firstTime = 0
        minZ = 1000;
        let center2 = [0, 0, 0];
        // let vertexCount2 = 0;
        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            center2[0] += geom.attributes[0][i][0];
            center2[1] += geom.attributes[0][i][1];
            center2[2] += geom.attributes[0][i][2];
        }
        center2[0] /= geom.attributes[0].length;
        center2[1] /= geom.attributes[0].length;
        center2[2] /= geom.attributes[0].length;

        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            geom.attributes[0][i][0] -= center2[0];
            geom.attributes[0][i][1] -= center2[1];
            geom.attributes[0][i][2] -= center2[2];
        }
    }
   
    center = [0, 0, 0]
    for (let i = 0; i < geom.attributes[0].length; i += 1) {
        for (let j = 0; j < 2; j += 1) {
            center[j] += geom.attributes[0][i][j];
        }
    }
    center[0] /= geom.attributes[0].length;
    center[1] /= geom.attributes[0].length;
    center[2] /= geom.attributes[0].length;

    // console.log(" old geom: ", geom)
    // console.log("FlooroRCUBe = ", floorOrCube)
    if (floorOrCube == 0 && firstTime == 0) {
        firstTime = -1
        // console.log("FIELPATH:: ", filePath)
        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            geom.attributes[0][i][0] -= center[0];
            geom.attributes[0][i][1] -= center[1];
            geom.attributes[0][i][2] -= center[2];
        }
    }
    if (calcNormals === 1) {
        let ni = geom.attributes.length
        geom.attributes.push([])
        for(let i = 0; i < geom.attributes[0].length; i+=1) {
            geom.attributes[ni].push([0,0,0])
        }
        
        for(let i = 0; i < geom.triangles.length; i+=1) {
            let p0 = geom.attributes[0][geom.triangles[i][0]]
            // console.log(p0)
            let p1 = geom.attributes[0][geom.triangles[i][1]]
            // console.log("hellooo")
            // console.log(p1)
            let p2 = geom.attributes[0][geom.triangles[i][2]]
            let e1 = [p1[0] - p0[0], p1[1] - p0[1], p1[2] - p0[2]]
            let e2 = [p2[0] - p0[0], p2[1] - p0[1], p2[2] - p0[2]]
            
            let n = [
                e1[1] * e2[2] - e1[2] * e2[1],  
                e1[2] * e2[0] - e1[0] * e2[2],  
                e1[0] * e2[1] - e1[1] * e2[0]   
            ];
            geom.attributes[ni][geom.triangles[i][0]] = add(geom.attributes[ni][geom.triangles[i][0]], n)
            geom.attributes[ni][geom.triangles[i][1]] = add(geom.attributes[ni][geom.triangles[i][1]], n)
            geom.attributes[ni][geom.triangles[i][2]] = add(geom.attributes[ni][geom.triangles[i][2]], n)
        }
        
        for(let i = 0; i < geom.attributes[0].length; i+=1) {
            geom.attributes[ni][i] = normalize(geom.attributes[ni][i])
        }
    } else if (calcNormals === 2) {
        // console.log("pushing given normals 2")
        for(let i = 0; i < parsedNormals.length; i+=1) {
            normals[i] = normalize(parsedNormals[i])
        }
        geom.attributes.push(parsedNormals)
        let i = 0;
        while (normals.length < geom.attributes[0].length) {
            normals.push(normals[i])
            i += 1
        }
    } else {
        
        // console.log("pushing given normals")
        for(let i = 0; i < normals.length; i+=1) {
            normals[i] = normalize(normals[i])
        }
        geom.attributes.push(normals)
    
    }
    if (texCoords.length !== 0 && useTexture === 1) {
        // console.log("using texture")
        geom.attributes.push(texCoords)
        // if (colorsGiven === 0) {
        let vertLength = 0;
        if (useParsed === 1) {
            vertLength = parsedVertices.length;
        } else {
            vertLength = vertices.length
        }
        // the bitch
        for (let i = 0; i < vertLength; i+=1) {
            if (filePath != "cube.obj") {
                color[i] = [1, 1, 1]
            } else {
                color[i] = [1, 0, 0]
            }
        }
        geom.attributes.color = color;
        // }
    } else if (texCoords.length === 0){
        // console.log("adding texcoords cuz theres none")
        let vertLength = 0;
        if (useParsed === 1) {
            vertLength = parsedVertices.length;
        } else {
            vertLength = vertices.length
        }
        for (let i = 0; i < vertLength; i+=1) {
            texCoords.push([1,1])
        }
        geom.attributes.push(texCoords)
    } else {
        // console.log("not using texture")
        let vertLength = 0;
        if (useParsed === 1) {
            vertLength = parsedVertices.length;
        } else {
            vertLength = vertices.length
        }
        for (let i = 0; i < vertLength; i+=1) {
            texCoords.push([1,1])
        }
        geom.attributes.push(texCoords)
    }
    

    // console.log("addnormals geom post norm:")
    // console.log(geom)
}
</script>

<link href='https://fonts.googleapis.com/css?family=Rubik' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Shrikhand' rel='stylesheet'>
<style>
    body {
      background-color: #89CFF0; 
      margin: 0;
      padding-left: 20px;
      padding-top: 10px;
      font-family: American Typewriter, serif;
      /* font-family: Rubik; */
    }
    .container {
        display: flex;
        justify-content: center; /* Centers the canvas horizontally */
        align-items: flex-start;
        /* gap: 20px; Space between controls and canvas */
    }

    .controls {
        text-align: left; /* Ensures text stays left-aligned */
        min-width: 150px; /* Prevents controls from shrinking too much */
        margin-right: 7.5vh;
        margin-right: 10vh;
    }

    #glCanvas {
        display: block;
        margin: 20px auto;
        margin-left: 20vh;
        margin-right: 8vh;
        width: 100vh;  
        min-width: 60vh;
        height: 62.5vh;  
        border: 3px solid #000;
        border-radius: 40px;
    }

    li {
        margin: 10px 0;
    }

    .overlay {
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 102px; 
        background-color: #003366; 
        z-index: 0;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); 
    }

    a {
        text-decoration: none;
        color: rgba(250, 198, 66, 0.926);
        font-size:10px;
        margin:2px;
    }

    .header {
        display: flex;
        position: relative;
        z-index: 1; 
        align-items: center;
        color: rgba(250, 198, 66, 0.926);
    }


  </style>
</head>
<body>
    <div class="overlay"></div>
    <div class="header">
        <img src="rubixcube.png" alt="rubik's cube icon" style="width:80px;height:80px; margin-right: 10px;">
        <div style="display: flex; flex-direction: column;">
            <p style="font-family: Shrikhand; font-size:30px;  margin:0;">Custom 2x2x2 Rubik's Cube</p>
            <b style="font-size:12px; margin: 0;"><i>BETA 0.5.1 - COMING SOON: 3x3x3</i></b>
            <a href="https://chrisMonzon.github.io">© 2025 Christoper Monzon</a>
        </div>
    </div>    
    <div style="white-space: pre; font-size:3px;"></div>
    <br>
    <p style="font-size:10px;">Upload a .OBJ file to create a 2x2x2 Rubik's cube!</p>
    
    <form class="controls" action="javascript:void(0);">
        <label style="font-size:10px;">
            <b>Upload OBJ file:</b>
          <input id="objUpload" type="file" accept=".obj" />
        </label>
        <input id="submit" type="submit" value="Load" />
      </form>
      <button id="scrambleButton" style="margin-top: 10px;">Scramble Cube</button>

      <br>
    <!-- <form class="controls" action="javascript:void(0);"> -->
        
        <!-- <label>Provided assets: <input id="file_path" type="text" value="path.obj" /></label> -->
        <!-- <label>Image path: <input id="image_path" type="text" value="path.png" /></label> -->
        <div id="currAxis" style="font-size:13px;"></div>
        <!-- <input id="submit" type="submit" value="Load" /> -->
    <!-- </form> -->
    
    <div class="container">
        <!-- <div style="display: flex; flex-direction: column;"> -->
        <canvas id="glCanvas" width="1200" height="600"></canvas>
        <div class="controls" style="font-size:8px;">
            <br>
            <br>
        <b style="font-size: 15px;">Rubik's move controls:</b>
        <p style="font-size: 10px;">The rotation hotkeys match with </p>
        <p style="font-size: 10px;">  the notation below:</p>
        <img src="ref.png" alt="rubik's cube icon" style="width:200px;height:200px;">
        <br>
        <br>
        <b style="font-size: 15px;">Other controls:</b>
        <ul style="font-size:10px;">
            <li> ↑ ↓ → ← : Camera rotation</li>
            <li> w/a/s/x : Forward/left/backward/right</li>
            <li> q : Rotate whole model down</li>
            <li> e : Rotate whole model right</li>
            <li>shift: invert rotation direction</li>
        </ul>
        </div>
    </div>
    <!-- All the other code in one big script element. -->
<script>
    var thing;
    var thing2;
    var head;
    var body;
    
    function multiplyMatrixByVector(matrix, vector) {
        let result = [0, 0, 0];

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                result[i] += matrix[i * 3 + j] * vector[j];
            }
        }

        return result;
    }

    function transposeMatrix(matrix) {
        let transposed = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ];

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                transposed[j * 3 + i] = matrix[i * 3 + j];
            }
        }

        return transposed;
    }

    function rotate2(angle, axis) {
        cosAngle = Math.cos(angle);
        sinAngle = Math.sin(angle);
        axis2 = normalize2(axis);
        let ident =  new Float32Array([1, 0, 0, 
                      0, 1, 0,
                      0, 0, 1]);
        // identity matrix of cos0
        let identAngle = new Float32Array([cosAngle, 0, 0,
                           0, cosAngle, 0,
                           0, 0, cosAngle]);
        // identity matrix of sin0
        let identAngle2 = new Float32Array([sinAngle, 0, 0,
                          0, sinAngle, 0,
                          0, 0, sinAngle]);
        let term1 = m3mul(identAngle, ident);
        // 1 - cos0
        let negIdentAngle = new Float32Array([1 - cosAngle, 0, 0,
                            0, 1 - cosAngle, 0,
                            0, 0, 1 - cosAngle]);
        // (aa^T)(1-cos0)
        let term2 = new Float32Array([axis2[0] * axis2[0], axis2[0] * axis2[1], axis2[0] * axis2[2],
                                    axis2[0] * axis2[1], axis2[1] * axis2[1], axis2[1] * axis2[2],
                                    axis2[0] * axis2[2], axis2[1] * axis2[2], axis2[2] * axis2[2]]);
        // term2 = multiplyMatrices(negIdentAngle, term2)
        term2 = m3mul(negIdentAngle, term2);
        let term3 = m3mul(identAngle2, m3transpose(new Float32Array(([0, -1 * axis2[2], axis2[1],
                                                                    axis2[2], 0, -1 * axis2[0],
                                                                    -1 * axis2[1], axis2[0], 0]))));
        // let final = addMatrices(addMatrices(term1, term2), term3);
        let final =  new Float32Array([0, 0, 0, 
                      0, 0, 0,
                      0, 0, 0]);
        // console.log("term1 = ", term1)
        // console.log("term2 = ", term2)
        // console.log("term3 = ", term3)
        final = m3add(final, term1)
        final = m3add(final, term2)
        final = m3add(final, term3)
        // console.log("final = ", final)
        return final;
    }


    function intersectEdgeWithPlane(v1, v2, planeDim, planeCoord) {
        // console.log("v2 = ", v2, "v1 = ", v1)
        let d = v2[planeDim] - v1[planeDim];
        let t = (planeCoord - v1[planeDim]) / d;
        return [
            v1[0] + t * (v2[0] - v1[0]),
            v1[1] + t * (v2[1] - v1[1]),
            v1[2] + t * (v2[2] - v1[2])
        ];
    }

    function offsetPoint(point, planeDim, offset) {
        let newPoint = point.slice(); // copy the array
        newPoint[planeDim] += offset;
        return newPoint;
    }

    function partitionOBJ(geom, planeDim, planeCoord) {
        let vertices = geom.attributes[0]
        let gapVal = 0.001// 4
        // console.log("tirCount = ", geom.triangles.length)
        let count = geom.triangles.length
        
        let posFaces = []
        let negFaces = []
        for (let i = geom.triangles.length - 1; i >= 0; i -= 1) {
            let tri = geom.triangles[i]
            for (let jk = 0; jk < 3; jk += 1) {
                // console.log("CurrVert = ", tri[jk], "j = ", jk)
                if (vertices[tri[jk]][planeDim] < planeCoord) { 
                    // geom.triangles.splice(i, 1);
                    posFaces.push(geom.triangles[i])
                    break
                } 
                else {
                    negFaces.push(geom.triangles[i])
                    break
                }
            }
        }
        // testing too much eating
        // for (let i = geom.triangles.length - 1; i >= 0; i -= 1) {
        //     let tri = geom.triangles[i]
        //     for (let jk = 0; jk < 3; jk += 1) {
        //         // console.log("CurrVert = ", tri[jk], "j = ", jk)
        //         if (vertices[tri[jk]][planeDim] < planeCoord) { 
        //             // geom.triangles.splice(i, 1);
        //             posFaces.splice(i, 1)
        //             break
        //         } 
        //         else {
        //             // negFaces.push(geom.triangles[i])
        //             break
        //         }
        //     }
        // }
        posGeom = {"triangles" : posFaces, "attributes" : geom.attributes}
        negGeom = {"triangles" : negFaces, "attributes" : geom.attributes}
        // console.log("finished partitioning!!", posGeom, negGeom)
        
        return [posGeom, negGeom]
    }

    function partitionOBJinit(geom, planeDim, planeCoord) {
        let vertices = geom.attributes[0]
        let gapVal = 0.001// 4
        // console.log("tirCount = ", geom.triangles.length)
        let count = geom.triangles.length
        
        // for (let i = 0; i < geom.attributes[0].length; i += 1) {
        //     if (geom.attributes[0][i][planeDim] >= planeCoord) {
        //         for (let j = 0; j < 3; j += 1) {
        //             if (j == planeDim) {
        //                 geom.attributes[0][i][j] += 20.0 * gapVal
        //             }
        //         }
        //     } else {
        //         for (let j = 0; j < 3; j += 1) {
        //             if (j == planeDim) {
        //                 geom.attributes[0][i][j] -= 20.0 * gapVal
        //             }
        //         }
        //     }
        // }
        // make global
        let vertMap = new Map();

        // for (let i = 0; i < count; i += 1) {
        //     let tri = geom.triangles[i]
        //     for (let jk = 0; jk < 3; jk += 1) {
        //         if (vertices[tri[jk]][planeDim] >= planeCoord) { 
        //             vertMap[vertices[tri[jk]]] = -1
        //         } 
        //         else {
        //             vertMap[vertices[tri[jk]]] = 1
        //         }
        //     }
        // }

        for (let i = 0; i < geom.attributes[0].length; i += 1) {
            if (geom.attributes[0][i][planeDim] >= planeCoord) { 
                // vertMap[vertices[tri[jk]]] = -1
                geom.attributes[0][i][planeDim] += gapVal * 2
            } 
            else {
                // vertMap[vertices[tri[jk]]] = 1
                geom.attributes[0][i][planeDim] -= gapVal * 2
            }

        }
        for (let i = 0; i < count; i += 1) {
            let tri = geom.triangles[i]
            let posVerts = []
            let negVerts = []
            let triangleToRemoveIndex = i;
            for (let jk = 0; jk < 3; jk += 1) {
                if (tri[jk] == -1) {
                    break
                }
                if (vertices[tri[jk]][planeDim] >= planeCoord) { 
                    posVerts.push(vertices[tri[jk]])
                    // vertMap[vertices[tri[jk]]] = -1
                } 
                else {
                    negVerts.push(vertices[tri[jk]])
                    // vertMap[vertices[tri[jk]]] = 1
                }
            }
            // console.log("pv = ", posVerts, "nv = ", negVerts)
            // console.log("pvL = ", posVerts.length, "nvL = ", negVerts.length)
            
            if (!(posVerts.length === 3 || negVerts.length === 3)) {
                // determine the coordinates of where the plane and the triangle intersect
                // determine 2 points on both sides of the plane offset by 0.01
                let newTriIndex = geom.triangles.length
                let newVertIdx = geom.attributes[0].length
                if (posVerts.length > negVerts.length) { // more pos than neg
                    // console.log("fist case")
                    let intPointA = intersectEdgeWithPlane(posVerts[0], negVerts[0], planeDim, planeCoord)
                    let intPointB = intersectEdgeWithPlane(posVerts[1], negVerts[0], planeDim, planeCoord)
                    // console.log("int points: ", intPointA, " ", intPointB)
                    // create offset points from the intersection to create gaps in the middle of the object
                    let newPointA = offsetPoint(intPointA, planeDim, gapVal)
                    let newPointB = offsetPoint(intPointB, planeDim, gapVal)
                    let newPointC = offsetPoint(intPointA, planeDim, -gapVal)
                    let newPointD = offsetPoint(intPointB, planeDim, -gapVal)
                    // console.log("A, B, C, D: ", newPointA, newPointB, newPointC, newPointD)
                    // add offset vertices from intersection to geometry json
                    geom.attributes[0].push(newPointA)
                    geom.attributes[0].push(newPointB)
                    geom.attributes[0].push(newPointC)
                    geom.attributes[0].push(newPointD)
                    // vertMap[newPointA] = 
                    // remove the triangle that we split from the geometry
                    let posVerts0Idx = geom.attributes[0].indexOf(posVerts[0])
                    let posVerts1Idx = geom.attributes[0].indexOf(posVerts[1])
                    let negVerts0Idx = geom.attributes[0].indexOf(negVerts[0])
                    geom.triangles[triangleToRemoveIndex] = [newVertIdx, newVertIdx + 1, posVerts0Idx]
                    geom.triangles.push([newVertIdx + 1, posVerts0Idx, posVerts1Idx])
                    geom.triangles.push([newVertIdx + 2, newVertIdx + 3, negVerts0Idx])
                } else {
                    // console.log("second case")
                    let intPointA = intersectEdgeWithPlane(negVerts[0], posVerts[0], planeDim, planeCoord)
                    let intPointB = intersectEdgeWithPlane(negVerts[1], posVerts[0], planeDim, planeCoord)
                    // create offset points from the intersection to create gaps in the middle of the object
                    let newPointA = offsetPoint(intPointA, planeDim, -gapVal)
                    let newPointB = offsetPoint(intPointB, planeDim, -gapVal)
                    let newPointC = offsetPoint(intPointA, planeDim, gapVal)
                    let newPointD = offsetPoint(intPointB, planeDim, gapVal)
                    // add offset vertices from intersection to geometry json
                    geom.attributes[0].push(newPointA)
                    geom.attributes[0].push(newPointB)
                    geom.attributes[0].push(newPointC)
                    geom.attributes[0].push(newPointD)
                    // remove the triangle that we split from the geometry
                    let negVerts0Idx = geom.attributes[0].indexOf(negVerts[0])
                    let negVerts1Idx = geom.attributes[0].indexOf(negVerts[1])
                    let posVerts0Idx = geom.attributes[0].indexOf(posVerts[0])
                    geom.triangles[triangleToRemoveIndex] = [newVertIdx, newVertIdx + 1, negVerts0Idx]
                    geom.triangles.push([newVertIdx + 1, negVerts0Idx, negVerts1Idx])
                    geom.triangles.push([newVertIdx + 2, newVertIdx + 3, posVerts0Idx])
                }
            }
        }
        let posFaces = []
        let negFaces = []
        for (let i = geom.triangles.length - 1; i >= 0; i -= 1) {
            let tri = geom.triangles[i]
            for (let jk = 0; jk < 3; jk += 1) {
                // console.log("CurrVert = ", tri[jk], "j = ", jk)
                if (vertices[tri[jk]][planeDim] < planeCoord) { 
                    // geom.triangles.splice(i, 1);
                    posFaces.push(geom.triangles[i])
                    break
                } 
                else {
                    negFaces.push(geom.triangles[i])
                    break
                }
            }
        }
        // return geom
        posGeom = {"triangles" : posFaces, "attributes" : geom.attributes}
        negGeom = {"triangles" : negFaces, "attributes" : geom.attributes}
        // console.log("finished partitioning!!", posGeom, negGeom)
        return [posGeom, negGeom]
    }

    function computeCentroid(vertices) {
        let center = [0, 0, 0];
        let count = 0;
        for (let v of vertices) {
            center[0] += v[0];
            center[1] += v[1];
            center[2] += v[2];
            count++;
        }
        if (count > 0) {
            center[0] /= count;
            center[1] /= count;
            center[2] /= count;
        }
    
        return center;
    }

    function computeObjectMid(vertices) {
        let center = [0, 0, 0];
        let count = 0;

        let minX = vertices[0][0];
        let maxX = vertices[0][0];
        let minY = vertices[0][1];
        let maxY = vertices[0][1];
        let minZ = vertices[0][2];
        let maxZ = vertices[0][2];
        for (let i = 0; i < vertices.length; i += 1) {
            if (vertices[i][0] < minX) {
                minX = vertices[i][0];
            }
            if (vertices[i][0] > maxX) {
                maxX = vertices[i][0];
            }
            if (vertices[i][1] < minY) {
                minY = vertices[i][1];
            }
            if (vertices[i][1] > maxY) {
                maxY = vertices[i][1];
            }
            if (vertices[i][2] < minZ) {
                minZ = vertices[i][2];
            }
            if (vertices[i][2] > maxZ) {
                maxZ = vertices[i][2];
            }
        }
        return [Math.abs(maxX - minX) / 2.0, Math.abs(maxY - minY) / 2.0, Math.abs(maxZ - minZ) / 2.0]
        // return center;
    }


    function left(axis, degrees, mode, planeCoord) {
        let topVerts = [];
        
        var center2 = [0, 0, 0]; 
        // let valid = ((mode == "top" && thing.attributes[0][i][2] > 0.0) || (mode == "bottom" && thing.attributes[0][i][2] < 0.0) || (mode == "left" && thing.attributes[0][i][0] < 0.0) || (mode == "right" && thing.attributes[0][i][0] > 0.0))
        // if (mode == "top" || mode == "bottom") {
        for (let i = 0; i < thing.attributes[0].length; i++) {
            if ((mode == "top" && thing.attributes[0][i][2] > planeCoord) || (mode == "bottom" && thing.attributes[0][i][2] < planeCoord)
                || (mode == "left" && thing.attributes[0][i][0] < planeCoord) || (mode == "right" && thing.attributes[0][i][0] > planeCoord)
                || (mode == "back" && thing.attributes[0][i][1] >= planeCoord) || (mode == "front" && thing.attributes[0][i][1] < planeCoord)) {
                topVerts.push(thing.attributes[0][i]);
            }
        }
        if (mode != "all") {
            center2 = computeCentroid(topVerts);
        }
        // }
        for (let i = 0; i < thing.attributes[0].length; i += 1) {
            xC = thing.attributes[0][i][0]
            yC = thing.attributes[0][i][1]
            zC = thing.attributes[0][i][2]
            if (mode == "all") {
                thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
            } else if (mode == "left") {
                if (xC < planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            }  else if (mode == "right") {
                if (xC >= planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            } else if (mode == "top") {
                if (zC >= planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            } else if (mode == "bottom") {
                if (zC < planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            }
            else if (mode == "back") {
                if (yC >= planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            } else if (mode == "front") {
                if (yC < planeCoord) {
                    thing.attributes[0][i] = multiplyMatrixByVector(rotate2(degrees, axis), thing.attributes[0][i]);
                }
            }
        }
        // if (mode == "top" || mode == "bottom" ) {
        let topVerts2 = []
        for (let i = 0; i < thing.attributes[0].length; i++) {
            if ((mode == "top" && thing.attributes[0][i][2] > planeCoord) || (mode == "bottom" && thing.attributes[0][i][2] < planeCoord) 
            || (mode == "left" && thing.attributes[0][i][0] < planeCoord) || (mode == "right" && thing.attributes[0][i][0] > planeCoord)
            || (mode == "back" && thing.attributes[0][i][1] >= planeCoord) || (mode == "front" && thing.attributes[0][i][1] < planeCoord)) {
                topVerts2.push(thing.attributes[0][i]);
            }
            
        }
        if (mode != "all") {
        let center3 = computeCentroid(topVerts2);
        let toAdd = [center2[0] - center3[0], center2[1] - center3[1], center2[2] - center3[2],]
        }
    }

    /** Draw one frame */
    function draw(seconds) {
    
        // NON TEXTURE SHADER
        gl.clearColor(...IlliniWhite) // white background
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        gl.useProgram(programDef)
        
        let v = m4view(eye, [0,0,0], [0,1,1])
        let vScalar = 2.8
        v = m4mul(v, m4scale(vScalar * 0.9,vScalar,vScalar));
        gl.uniformMatrix4fv(programDef.uniforms.mv, false, v) // , m4mul(v,m)
        gl.uniformMatrix4fv(programDef.uniforms.p, false, p)
        
        gl.uniform3fv(programDef.uniforms.lightcolor, [1,1,1])

        // BUILDING SUN MATRIX:
        let sunRotSpeed = (seconds * Math.PI) // spinning a full rotation once every two seconds
        // sunRotSpeed = 20;
        let m = m4rotZ(sunRotSpeed / 10) 
        m = m4rotY(0) 

        let msmall = m4tom3(m)
        let mfinal = m3mul(msmall, normalize([1,1,1]))
        gl.uniform3fv(programDef.uniforms.lightdir, mfinal)
        gl.uniform3fv(programDef.uniforms.halfway, normalize([mfinal[0], mfinal[1], mfinal[2] + 1]))

        // let m = m4rotY(0) 
        // let sun =  m4mul(m, m4rotX(-1.5708) , m4scale(.2,.2,.2)) // sun
        // let sun =  m4mul(m4trans(0, 0, 0), m, m4rotX(1.5708))
        let sun =  m4mul(m, m4rotZ(dz), m4rotX(dy),m4scale(wd, wd, wd),m4trans(pd,0,0))
        k = 1

        // PLANE:
        gl.bindVertexArray(geomB.vao)
        k = 2
        gl.uniformMatrix4fv(programDef.uniforms.mv, false, m4mul(v,sun, m4scale(k,k,k)))
        gl.drawElements(geomB.mode, geomB.count, geomB.type, 0)

        gl.bindVertexArray(geomC.vao)

        //CUBE:
        // gl.enable(gl.BLEND);
        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        
        // // HEAD:
        // gl.disable(gl.DEPTH_TEST);  // Disable depth testing for transparent objects
        // h = 1
        // // gl.uniformMatrix4fv(programDef.uniforms.mv, false, m4mul(v,sun, m4trans(0,0,.75),m4scale(h, h, h)))
        // // gl.drawElements(geomC.mode, geomC.count, geomC.type, 0)
        // // BODY:
        // gl.uniformMatrix4fv(programDef.uniforms.mv, false, m4mul(v,sun, m4trans(0,0,0), m4scale(h, h, h)))
        // gl.drawElements(geomC.mode, geomC.count, geomC.type, 0)
        // gl.enable(gl.DEPTH_TEST);  // Disable depth testing for transparent objects


        // OBJECT:
        k = 1
        gl.bindVertexArray(geomA.vao)
        gl.uniformMatrix4fv(programDef.uniforms.mv, false, m4mul(v,sun, m4scale(k,k,k)))
        gl.drawElements(geomA.mode, geomA.count, geomA.type, 0)
        
            
    }
    
    /** Compute any time-varying or animated aspects of the scene */
    let previousSecond = 0;
    var rightFlag = 1.0;
    var cubeDim = 2
    var sign = 1;

    function rotateHalf(val) {
        let kk = cubeDim == 3 ? 0.05 : 0.0;
        // let val = 0;
        let ax = right;
        let planeNum = -1;
        var rotMode;
        var rotSign = 0;
        if (val == 0) {
            ax = forward
            planeNum = 2;
            rotMode = "top"
            rotSign = 1.0
        } else if (val == 1) {
            ax = forward
            planeNum = 2;
            rotSign = -1.0
            rotMode = "bottom"
        } else if (val == 2) {
            ax = up
            planeNum = 1;
            rotMode = "back"
            rotSign = 1.0
        } else if (val == 3) {
            ax = up
            planeNum = 1;
            rotMode = "front"
            rotSign = -1.0
        } else if (val == 4) {
            planeNum = 0;
            rotMode = "left"
            rotSign = -1.0
        } else if (val == 5) {
            
            planeNum = 0;
            rotMode = "right"
            rotSign = 1.0
        } 
        let part = partitionOBJ(thing, planeNum, kk)
        thing.triangles = part[0].triangles
        while (thing.attributes[1].length < thing.attributes[0].length) {
            thing.attributes[1].push([1.0, 1.0, 0.9])
        }
        left(ax, sign * Math.PI/2.0, rotMode, rotSign * kk)
        for (let i = 0; i < part[1].triangles.length; i += 1) {
            thing.triangles.push(part[1].triangles[i])
        }
        addNormals(thing)
        window.geomA = setupGeomery(thing)
        thing.attributes = [thing.attributes[0], thing.attributes[1], thing.attributes[2], thing.attributes[3]]
        fillScreen()
        window.addEventListener('resize', fillScreen)
        return rotMode;
    }

    function scramble() {
        let cheatSheet = ""
        for (let i = 0; i < 20; i += 1) {
            let randVal = Math.floor(Math.random() * 6);
            cheatSheet = "\n" + rotateHalf(randVal) + "\n" + cheatSheet;
        }
        console.log("Cheat sheet: ", cheatSheet)
    }
    document.getElementById('scrambleButton').addEventListener('click', scramble);
    
    function tick(milliseconds) {
        let seconds = milliseconds / 1000;
        // let sign = 1
        draw(seconds)
        requestAnimationFrame(tick)
        if (keysBeingPressed['ArrowUp']) {
            center = [eye[0] + 0.02 * forward[0], eye[1] + 0.02 * forward[1], eye[2] + 0.02 * forward[2]]
            dy += 0.01
        } 
        if (keysBeingPressed['ArrowDown']) {
            center = [eye[0] + 0.02 * forward[0], eye[1] + 0.02 * forward[1], eye[2] + 0.02 * forward[2]]
            dy -= 0.01
        } 
        if (keysBeingPressed['ArrowRight']) {
            dz += 0.01
            center = [eye[0] + 0.02 * forward[0], eye[1] + 0.02 * forward[1], eye[2] + 0.02 * forward[2]]
        } 
        if (keysBeingPressed['ArrowLeft']) {
            dz -= 0.01
            center = [eye[0] + 0.02 * forward[0], eye[1] + 0.02 * forward[1], eye[2] + 0.02 * forward[2]]
        } 
        if (keysBeingPressed['w']) {
            wd += 0.005
        } 
        if (keysBeingPressed['s']) {
            wd -= 0.005
        } 
        if (letsGo) {
            let kk = cubeDim == 3 ? 0.05 : 0.0
            if (keysBeingPressed["Shift"]) {
                sign *= -1
            } 
            if (keysBeingPressed['q']) {
                let ax = right
                ax = [1, 0, 0]
                left(ax, Math.PI/2.0, "all", kk)
                addNormals(thing)
                window.geomA = setupGeomery(thing)
                thing.attributes = [thing.attributes[0], thing.attributes[1], thing.attributes[2], thing.attributes[3]]
                fillScreen()
                window.addEventListener('resize', fillScreen)
            } if (keysBeingPressed['e']) {
                let ax = right
                ax = [1, 0, 0]
                left(forward, Math.PI/2.0, "all", kk)
                addNormals(thing)
                window.geomA = setupGeomery(thing)
                thing.attributes = [thing.attributes[0], thing.attributes[1], thing.attributes[2], thing.attributes[3]]
                fillScreen()
                window.addEventListener('resize', fillScreen)
            } if (keysBeingPressed['l']) { // left half rotation
                rotateHalf(4);
            } if (keysBeingPressed['r']) { // right half rotation
                rotateHalf(5);
            } if (keysBeingPressed['u']) { // top half rotation
                rotateHalf(0);
            } if (keysBeingPressed['d']) { // bottom half rotation
                rotateHalf(1);
            } if (keysBeingPressed['b']) { // front half
                rotateHalf(2);
            } if (keysBeingPressed['f']) { // bottom half
                rotateHalf(3);
            } 
        }
        if (keysBeingPressed['x']) {
            // pd += 0.005
            eye = [eye[0] + 0.02 * right[0], eye[1] + 0.02 * right[1], eye[2] + 0.02 * right[2]]
            center = [center[0] + 0.02 * right[0], center[1] + 0.02 * right[1], center[2] + 0.02 * right[2]]
        } 
        if (keysBeingPressed['a']) {
            // pd -= 0.005
            eye = [eye[0] - 0.02 * right[0], eye[1] - 0.02 * right[1], eye[2] - 0.02 * right[2]]
            center = [center[0] - 0.02 * right[0], center[1] - 0.02 * right[1], center[2] - 0.02 * right[2]]
        } 

        let printVar;
        if (sign == 1) {
            printVar = "⊕"
        } else {
            printVar = "⊖"
        }
        document.getElementById('currAxis').textContent = `Rotation direction: ${printVar}`;
    }
    
    /** Resizes the canvas to completely fill the screen */
    function fillScreen() {
        let canvas = document.querySelector('canvas')
        document.body.style.margin = '0'
        canvas.style.width = '100vw'
        canvas.style.height = '100vh'
        canvas.width = canvas.clientWidth
        canvas.height = canvas.clientHeight
        canvas.style.width = ''
        canvas.style.height = ''
        if (window.gl) {
            // gl.viewport(0,0, canvas.width, canvas.height)
            gl.viewport(-1,1, canvas.width, canvas.height)
            // window.p = m4perspNegZ(1, 5, 1.5, canvas.width, canvas.height)
            window.p = m4perspNegZ(0.01, 10, 2, canvas.width, canvas.height)
        }
    }
    
    var calcNormals = 1
    var normals = []
    var faces = []
    var color = []
    var texCoords = []
    var parsedNormals = [];
    var dict;
    var vertices =[]
    var useTexture = 0;
    var colorsGiven;
    var useParsed = 0;
    var parsedVertices = [];
    var parsedTex = [];
    // OBJ parser function
    function parseOBJ(objData) {
        vertices = [];
        normals = [];
        dict = new Object();
        texCoords = [];
        faces = [];
        color = [];
        colorsGiven = 0;
        const lines = objData.split('\n');
        let count = 0;
        calcNormals = 1;
        useParsed = 0;
        parsedVertices = []; // Final array of unique vertices
        parsedNormals = []; // Final array of unique normals
        parsedTex = [];
        isCube = 0;
        if (objData[0] === 'z') {
            isCube = 1;
        }
        floorOrCube = 0;
        for (let line of lines) {
            line = line.trim();
            // console.log(line);
            if (line.startsWith('#') || line === '') continue;
    
            const parts = line.split(/\s+/);
            const prefix = parts[0];
            // console.log(line)
            switch (prefix) {
                case 'z':
                    isCube = 1;
                case 'y':
                    floorOrCube = 1;
                case 'v':
                    const numbers = parts.slice(1).map(Number); // Parse numbers directly
                    // console.log(line)
                    if (numbers.length === 3) {
                        // Push the 3 vertex coordinates
                        vertices.push([parseFloat(numbers[0]), parseFloat(numbers[1]), parseFloat(numbers[2])]);
                        // vertices.push(new Float32Array([parseFloat(numbers[0]), parseFloat(numbers[1]), parseFloat(numbers[2])]));
                        // console.log("Numbers = ", numbers, numbers[0])
                        // console.log("Pushing: ", [numbers[0], numbers[1], numbers[2]])
                    } else if (numbers.length === 6) {
                        // Push vertex and color separately
                        // console.log("Vertex with 6 values (including color) detected");
                        vertices.push([numbers[0], numbers[1], numbers[2]]); // Push the first 3 numbers to vertices
                        color.push([numbers[3], numbers[4], numbers[5]]);
                        // color.push(numbers.slice(3));          // Push the last 3 numbers as an array to color
                        colorsGiven = 1;
                    } else {
                        console.log(`Unexpected number of values after 'v': ${numbers.length}`);
                    }
                    break;

                case 'vn':
                    // console.log(line)
                    const numbers2 = parts.slice(1).map(Number); // Parse numbers directly
                    // normals.push(parts.slice(1).map(Number));
                    normals.push([numbers2[0], numbers2[1], numbers2[2]]);
                    calcNormals = 0
                    break;
                case 'vt':
                    // useTexture = 1;
                    const numbers3 = parts.slice(1).map(Number);
                    texCoords.push([numbers3[0], numbers3[1]]);
                    break;
                case 'f':
                    // console.log("true vertices = ", vertices)
                    const numberss = parts.slice(1).map(Number); // Parse numbers directly
                    if (parts[1].includes('//')) {
                        calcNormals = 2
                        useParsed = 1;
                        let iters = Math.ceil(numberss.length / 3)
                        if (dict[parts[1]] === undefined) {
                            dict[parts[1]] = count;
                            count += 1;
                            let vertnNorm = parts[1].split('//')
                            let vertex = vertices[parseInt(vertnNorm[0]) - 1]
                            let normal = normals[parseInt(vertnNorm[1]) - 1]
                            parsedVertices.push(vertex)
                            parsedNormals.push(normal)
                        }
                        for (let j = 0; j < iters; j += 1) {
                            let partList = [parts[1], parts[2 + j], parts[3 + j]]
                            for (let i = 2; i < 4; i += 1) {
                                if (dict[parts[i + j]] === undefined) {
                                    dict[parts[i + j]] = count;
                                    count += 1;
                                    let vertnNorm2 = parts[i + j].split('//')
                                    let vertex = vertices[parseInt(vertnNorm2[0]) - 1]
                                    let normal = normals[parseInt(vertnNorm2[1]) - 1]
                                    parsedVertices.push(vertex)
                                    parsedNormals.push(normal)
                                    // console.log("verty =", vertex)
                                    // console.log("normie =", normal)
                                }
                                
                            }
                            faces.push([dict[parts[1]], dict[parts[2 + j]], dict[parts[3 + j]]]);
                        }
                    } else if (parts[1].includes('/')) {
                        useParsed = 1;
                        calcNormals = 2
                        let iters = Math.ceil(numberss.length / 3)
                        let keySplit = parts[1].split('/')
                        let key0 = keySplit[0] + "/" + keySplit[2]
                        
                        if (dict[key0] === undefined) {
                            dict[key0] = count;
                            count += 1;
                            let vertnNorm = parts[1].split('/')
                            let vertex = vertices[parseInt(vertnNorm[0]) - 1]
                            // console.log("vertex = ", vertex)
                            let normal = normals[parseInt(vertnNorm[2]) - 1]
                            let tex = texCoords[parseInt(vertnNorm[1]) - 1]
                            parsedVertices.push(vertex)
                            parsedNormals.push(normal)
                            parsedTex.push(tex)
                        }
                        for (let j = 0; j < iters; j += 1) {
                            let partList = [parts[1], parts[2 + j], parts[3 + j]]
                            keys = [key0]
                            for (let i = 2; i < 4; i += 1) {
                                let keySplit = parts[i + j].split('/')
                                let key = keySplit[0] + "/" + keySplit[2]
                                keys.push(key)
                                // console.log("nested key = ", key)
                                if (dict[key] === undefined) {
                                    dict[key] = count;
                                    count += 1;
                                    let vertnNorm2 = parts[i + j].split('/')
                                    let vertex = vertices[parseInt(vertnNorm2[0]) - 1]
                                    let normal = normals[parseInt(vertnNorm2[2]) - 1]
                                    let tex = texCoords[parseInt(vertnNorm2[1]) - 1]
                                    parsedVertices.push(vertex)
                                    parsedNormals.push(normal)
                                    parsedTex.push(tex)
                                    // console.log("verty =", vertex)
                                    // console.log("normie =", normal)
                                }                       
                            }
                            faces.push([dict[keys[0]], dict[keys[1]], dict[keys[2]]]);
                        }
                    } else {
                        const nums = parts.slice(1).map(Number);
                        let iters = Math.ceil(numberss.length / 3)
                        for (let j = 0; j < iters; j += 1) {
                            faces.push([nums[0] - 1, nums[1 + j] - 1, nums[2 + j] - 1]);
                        }
                    }
                    break;
            }
        }
        // console.log("og texcoords: ", texCoords);
        texCoords = parsedTex;
        // console.log("parsed texcoords: ", texCoords);

        // console.log("vertices length =", parsedVertices.length)
        // console.log("normals length =", parsedNormals.length)
        // console.log("faces length =",faces.length)
        
        if (colorsGiven === 0) {
            
            let vertLength = 0;
            var vs;

            if (useParsed === 1) {
                vertLength = parsedVertices.length;
                vs = parsedVertices;
            } else {
                vertLength = vertices.length
                vs = vertices;
            }
            if (floorOrCube !== 1) {
                for(let i = 0; i < vertLength; i+=1) {
                    color.push([1.0,1.0,0.9])
                }
            } else {
                for (let i = 0; i < vertLength; i+=1) {
                    color.push([1.0,1.0,1.0])
                }
            }
            if (floorOrCube !== 1) {
                // ...
            } else {
                for (let i = 0; i < vertLength; i++) {
                    color.push([1.0, 1.0, 1.0]);
                }
            }

        }
        let toReturn = {};
        if (useParsed == 0) {
            toReturn =
            {"triangles":
                faces
            ,"attributes":
                [ // position
                    vertices
                , // colors
                color
                ]
            }
        } else {
            normals = parsedNormals
            toReturn =
            {"triangles":
                faces
            ,"attributes":
                [ // position
                    parsedVertices
                , // color
                color
                ]
            }
        }
        // console.log("texCoords: ", parsedTex)
        // console.log("useTexture = ", useTexture)
        // console.log("vertices = ", vertices)
        // console.log("post parse geom: ", toReturn)

        return toReturn
    }

    var forward;
    var right;
    var eye;
    var center;
    var up;
    var dx;
    var dy;
    var dz;
    var wd;
    var pd;
    var mainObj;
    var isCube = 0;


    function normalize2(vector) {
        const length = Math.sqrt(vector[0] ** 2 + vector[1] ** 2 + vector[2] ** 2);
        return [vector[0] / length, vector[1] / length, vector[2] / length];
    }

    function crossProduct2(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0],
        ];
    }

    function loadTexture(filename){
        let img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = filename;
        img.addEventListener('error', function() {
            console.warn("Failed to load image."); // use non-texture shader if fails
            useTexture = 0;
        });
        img.addEventListener('load', function() {
            // Now that the image has loaded make copy it to the texture.
            

            // console.log(filename, " loaded successfully")
            let slot = 0; // or a larger integer if this isn't the only texture
            let texture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0 + slot);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(
                gl.TEXTURE_2D, // destination slot
                0, // the mipmap level this data provides; almost always 0
                gl.RGBA, // how to store it in graphics memory
                gl.RGBA, // how it is stored in the image object
                gl.UNSIGNED_BYTE, // size of a single pixel-color in HTML
                img, // source data
            );
            gl.generateMipmap(gl.TEXTURE_2D);
            // console.log("loaded ", filename);
            useTexture = 1;
            });
    }

    var submitted = 0
    var filePath
    var firstTime = 1
    var letsGo = 0;

    document.getElementById('objUpload').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            const objText = e.target.result;
            // Parse the uploaded OBJ file.
            letsGo = 1;
            thing = parseOBJ(objText);
            // console.log("thing = ", thing)
            firstTime = 1;
            normOk = 1;
            let kk = 0.0
            addNormals(thing);
            // let c = computeObjectMid(thing.attributes[0])
            for (let i = 0; i < 3; i += 1) {
                // kk = c[i] / 3.0
                a = partitionOBJinit(thing, i, -kk)
                thing.triangles = a[0].triangles
                while (thing.attributes[1].length < thing.attributes[0].length) {
                    thing.attributes[1].push([1.0, 1.0, 0.9])
                }
                for (let i = 0; i < a[1].triangles.length; i += 1) {
                    thing.triangles.push(a[1].triangles[i])
                }
                addNormals(thing);
                let j = 0;
                while (thing.attributes[2].length < thing.attributes[0].length) {
                    thing.attributes[2].push(thing.attributes[2][j])
                    j += 1
                }
            }
            // console.log0
            // addNormals(thing);
            window.geomA = setupGeomery(thing);
            thing.attributes = [thing.attributes[0], thing.attributes[1], thing.attributes[2], thing.attributes[3]]
            // Optionally, update your scene (e.g., reset eye/center, re-render, etc.)
            console.log("User model loaded:", thing);
            fillScreen(); // adjust viewport if needed
        };
        reader.readAsText(file);
    });

    /** Compile, link, set up geometry */
    window.addEventListener('load', async (event) => {
        // if (submitted === 1) {
            window.gl = document.querySelector('canvas').getContext('webgl2',
                // optional configuration object: see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
                {antialias: false, depth:true, preserveDrawingBuffer:true}
            )
            let vs = document.querySelector('#vert').textContent.trim()
            let fs = document.querySelector('#frag').textContent.trim()
            let fs2 = document.querySelector('#fragDef').textContent.trim()
            window.program = compileShader(vs,fs)
            window.programDef = compileShader(vs,fs2)
            gl.enable(gl.DEPTH_TEST)

            let cube3s = "z\nv -0.500000 -0.500000 0.500000 \nv -0.500000  0.500000 0.500000\nv  0.500000  0.500000 0.500000\nv  0.500000 -0.500000 0.500000\nv -0.500000 -0.500000  1.500000\nv -0.500000  0.500000  1.500000\nv  0.500000  0.500000  1.500000\nv  0.500000 -0.500000  1.500000\nvn  1.000000  0.000000  0.000000\nvn -1.000000  0.000000  0.000000\nvn  0.000000  1.000000  0.000000\nvn  0.000000 -1.000000  0.000000\nvn  0.000000  0.000000  1.000000\nvn  0.000000  0.000000 -1.000000\nf 3//1 7//1 8//1\nf 3//1 8//1 4//1\nf 1//2 5//2 6//2\nf 1//2 6//2 2//2\nf 7//3 3//3 2//3\nf 7//3 2//3 6//3\nf 4//4 8//4 5//4\nf 4//4 5//4 1//4\nf 8//5 7//5 6//5\nf 8//5 6//5 5//5\nf 3//6 4//6 1//6\nf 3//6 1//6 2//6\n"
            let cube3s2 = "z\ny\nv -0.500000 -0.500000 -0.500000\n\nv -0.500000  0.500000 -0.500000\n\nv  0.500000  0.500000 -0.500000\n\nv  0.500000 -0.500000 -0.500000\n\nv -0.500000 -0.500000  0.500000\n\nv -0.500000  0.500000  0.500000\n\nv  0.500000  0.500000  0.500000\n\nv  0.500000 -0.500000  0.500000\n\nvn  1.000000  0.000000  0.000000\n\nvn -1.000000  0.000000  0.000000\n\nvn  0.000000  1.000000  0.000000\n\nvn  0.000000 -1.000000  0.000000\n\nvn  0.000000  0.000000  1.000000\n\nvn  0.000000  0.000000 -1.000000\n\nf 3//1 7//1 8//1\n\nf 3//1 8//1 4//1\n\nf 1//2 5//2 6//2\n\nf 1//2 6//2 2//2\n\nf 7//3 3//3 2//3\n\nf 7//3 2//3 6//3\n\nf 4//4 8//4 5//4\n\nf 4//4 5//4 1//4\n\nf 8//5 7//5 6//5\n\nf 8//5 6//5 5//5\n\nf 3//6 4//6 1//6\n\nf 3//6 1//6 2//6\n"
            let cubeStr = "z\nv 1.000000 -1.000000 -1.000000\nv 1.000000 -1.000000 1.000000\nv -1.000000 -1.000000 1.000000\nv -1.000000 -1.000000 -1.000000\nv 1.000000 1.000000 -0.999999\nv 0.999999 1.000000 1.000001\nv -1.000000 1.000000 1.000000\nv -1.000000 1.000000 -1.000000\nvt 1.000000 0.333333\nvt 1.000000 0.666667\nvt 0.666667 0.666667\nvt 0.666667 0.333333\nvt 0.666667 0.000000\nvt 0.000000 0.333333\nvt 0.000000 0.000000\nvt 0.333333 0.000000\nvt 0.333333 1.000000\nvt 0.000000 1.000000\nvt 0.000000 0.666667\nvt 0.333333 0.333333\nvt 0.333333 0.666667\nvt 1.000000 0.000000\nvn 0.000000 -1.000000 0.000000\nvn 0.000000 1.000000 0.000000\nvn 1.000000 0.000000 0.000000\nvn -0.000000 0.000000 1.000000\nvn -1.000000 -0.000000 -0.000000\nvn 0.000000 0.000000 -1.000000\nf 2/1/1 3/2/1 4/3/1\nf 8/1/2 7/4/2 6/5/2\nf 5/6/3 6/7/3 2/8/3\nf 6/8/4 7/5/4 3/4/4\nf 3/9/5 7/10/5 8/11/5\nf 1/12/6 4/13/6 8/11/6\nf 1/4/1 2/1/1 4/3/1\nf 5/14/2 8/1/2 6/5/2\nf 1/12/3 5/6/3 2/8/3\nf 2/12/4 6/8/4 3/4/4\nf 4/13/5 3/9/5 8/11/5\nf 5/6/6 1/12/6 8/11/6\n"
            // thing = parseOBJ(cubeStr)
            // thing = parseOBJ(cubeStr)
            // og thing below 
            // thing = parseOBJ("v -1 -1 -0.255987\nv 1  -1 -0.255987\nv 1 1 -0.255987\nv -1 1 -0.255987\nf 1 2 3\nf 4 3 1\n")
            thing = parseOBJ("y\nv 0 0 0\nv 0 0 0 \nv 0 0 0\nv 0 0 0\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nf 1 2 3\nf 4 3 1\n")
            addNormals(thing)
            // thing2 = parseOBJ("v -1 -1 -1\nv 1  -1 -1\nv 1 1 -1\nv -1 1 -1\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nf 1 2 3\nf 4 3 1\n")
            thing2 = parseOBJ("y\nv -0.75 -0.75 -0.5\nv 0.75  -0.75 -0.5\nv 0.75 0.75 -0.5\nv -0.75 0.75 -0.5\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nvn 0 0 1\nf 1 2 3\nf 4 3 1\n")
            // thing2 for testing
            // thing2 = parseOBJ(subdividedCube2)
            addNormals(thing2)
            // console.log("FLOOR")
            // console.log(thing2)
            // console.log(thing)
            window.geomA = setupGeomery(thing)
            window.geomB = setupGeomery(thing2)
            blueCube = parseOBJ(cube3s2);
            // blueCube = parseOBJ(subdividedCube);
            addNormals(blueCube)
            // console.log(blueCube)
            // for (let i = 0; i < blueCube.attributes[0].length; i+=1) {
            //     blueCube.attributes[0][i][2] += 1
            // }
            window.geomC = setupGeomery(blueCube)
            // console.log(blueCube)
            fillScreen()
            window.addEventListener('resize', fillScreen)
            eye = [0,-2,0.5];
            forward = [0, 0, -1];
            up = [0, 1, 0];
            center = [0, 0, 0]
            
            wd = 1;
            pd = 0;
            dx = 0;
            dy = 0;
            dz = 0;
            let crossP = crossProduct2(forward, up);
            // console.log("Crossp = ", crossP)
            right = normalize2(crossP);
            // console.log("Loaded")
            document.querySelector('#submit').addEventListener('click', event => {
                
                // let imagePath = document.getElementById('image_path').value;
                // loadTexture(imagePath);
                filePath = document.getElementById('file_path').value;
                firstTime = 1;
                letsGo = 1;
                fetch(filePath)
                    .then((res) => res.text())
                    .then((text) => {
                    // do something with "text"
                        thing = parseOBJ(text)
                        normOk = 1
                        addNormals(thing)
                        window.geomA = setupGeomery(thing)
                        // console.log(thing)
                        fillScreen()
                        window.addEventListener('resize', fillScreen)
                    })
                    .catch((e) => console.error(e));
            });
            requestAnimationFrame(tick)
        // }
    })
    window.keysBeingPressed = {}
    window.addEventListener('keydown', event => keysBeingPressed[event.key] = true)
    window.addEventListener('keyup', event => keysBeingPressed[event.key] = false)
    </script>
</body>

</html>

